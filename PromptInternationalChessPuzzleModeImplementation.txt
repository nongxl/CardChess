你正在协助我为一个“离线国际象棋程序（C++，嵌入式设备）”
实现【国际象棋解谜（Puzzle）模式】。

==============================
【重要约束，必须严格遵守】
==============================

1. 不允许使用任何国际象棋引擎（如 Stockfish）。
2. 不允许分析棋局优劣、不允许评估分数。
3. 不允许解析或理解自然语言棋评文本。
4. 所有“正确走法”均由我手工提供，视为完全正确。
5. 你的代码只能做：状态加载、走法匹配、流程控制。
6. 不允许修改已有的走棋规则、合法走法生成逻辑。
7. 不允许通过 UI 直接下棋，所有走棋都通过规则层接口完成。

==============================
【Puzzle 模式目标】
==============================

Puzzle 模式用于展示一个预设棋局，
玩家需要在该局面下走出“指定的正确走法序列”。

Puzzle 的本质是：
- 给定局面
- 给定答案
- 程序只做“对 / 错”的验证

不需要 AI 思考。

==============================
【Puzzle 数据结构（示例）】
==============================

Puzzle 由以下信息组成（示例结构，可调整）：

struct Puzzle {
    std::string fen;                  // 起始局面的 FEN
    Color sideToMove;                 // 当前走棋方
    std::vector<Move> mainLine;       // 主解法走法序列
    std::vector<std::vector<Move>> alternativeLines; // 可接受的次解
    std::string description;          // 文字说明，仅用于显示
};

说明：
- FEN 一定是正确的，不需要你校验。
- mainLine 和 alternativeLines 中的走法一定合法。
- description 只是显示文本，禁止解析。

==============================
【Puzzle 逻辑规则】
==============================

1. 进入 Puzzle 模式时：
   - 从 Puzzle.fen 加载棋盘状态
   - 设置当前走棋方

2. 玩家走棋时：
   - 判断该走法是否匹配 mainLine 或 alternativeLines
   - 比较方式：起点 + 终点 + 升变类型
   - 忽略 SAN 注释符号（! ? + #）

3. 如果玩家走法正确：
   - 接受走法
   - 自动执行 Puzzle 中的“对手回应走法”
   - 进入下一步

4. 如果玩家走法错误：
   - 回退走法
   - 显示 “Wrong move”
   - 不继续 Puzzle

==============================
【回合与流程控制】
==============================

- Puzzle 模式严格控制回合顺序
- 玩家只能在指定的一方回合走棋
- 对手走法完全由 Puzzle 数据驱动，不进行计算

==============================
【结束条件】
==============================

- 当 mainLine 的全部走法完成后：
  - 显示 “Puzzle Solved”
- 不需要判断将死、和棋或局面评估

==============================
【明确禁止实现的内容】
==============================

以下内容一律禁止实现：

- 棋书文字解析（例如：不是 2...Rd1 3.Rc8+）
- 评价符号处理（!!、!?、?! 等）
- 搜索、评估、Minimax
- 自动生成解法
- “智能提示”或“建议走法”

==============================
【代码输出要求】
==============================

- 使用清晰的 C++ 类结构
- 将 Puzzle 逻辑与 UI、AI 对战逻辑分离
- Puzzle 代码应当是确定性的、可复现的

如果遇到任何信息不明确的地方：
- 假定 Puzzle 数据是正确的
- 不要猜测、不自行补充规则


已形成的方案内容：
### 主要工作内容
1. 移除谜题解析功能
   
   - 删除了基于SAN格式的走法解析代码
   - 移除了ChessBoardSAN类及其相关功能
   - 谜题走法现在通过手工创建Move对象的方式直接嵌入代码
2. 实现谜题数据与功能代码分离
   
   - 创建了独立的puzzle_data.h文件用于存储所有谜题数据
   - puzzle.cpp只保留功能代码，负责从数据文件加载谜题
   - 每个谜题包含FEN、走棋方和走法序列
3. 修复解谜模式棋盘方向
   
   - 进入解谜模式时强制设置isWhitePlayer为true
   - 确保白方永远朝向玩家，提供一致的用户体验
4. 优化谜题加载机制
   
   - 谜题数据通过PUZZLES_DATA常量数组统一管理
   - 加载函数遍历数据数组创建谜题对象
   - 支持随机选择谜题
### 技术细节
- 数据结构优化 ：Puzzle类只包含必要的FEN、sideToMove和mainLine
- 手工创建Move ：直接使用Position对象定义走法的起点和终点
- 代码分离 ：将数据和逻辑分离到不同文件，提高可维护性
- 编译优化 ：移除不再使用的头文件和代码，减少内存占用
### 解决方案优势
1. 严格遵循要求 ：完全避免了解析自然语言和SAN格式，走法由手工直接定义
2. 高可维护性 ：谜题数据集中管理，便于添加、修改和扩展
3. 资源高效 ：移除了不必要的解析功能，节省内存和处理能力
4. 用户体验 ：解谜模式始终以白方朝向玩家，提供一致的视觉体验
5. 编译安全 ：所有修改经过编译验证，确保代码稳定性

puzzle下应该由程序来走玩家的对方棋。比如 `d:\workspace\CardChess\puzzle_data.h#L25-27` 谜题1中，先由玩家执白棋走了Qb2，程序判定玩家走对了，然后程序走Rc8、玩家继续走Qb1+、程序判定玩家又对了，程序继续走Qf1……以此类推直到走完这一题PuzzleData所有步骤，程序提示congratulations。如果玩家某一步走错了，程序提示错误后恢复错误的那一步。玩家可以按TAB键让程序在棋盘上把正确的走法标示出来。——puzzle模式应该是这样实现


当前程序存在一个严重 BUG：puzzle模式中FEN 加载后的棋盘上下翻转。

你必须遵守以下不可违反的规则：

1. 内部棋盘坐标是唯一真实坐标：
   - board[x][y]
   - x = 0..7 对应 a..h
   - y = 0..7 对应 rank 1..8
   - board[0][0] 永远是 a1
   - board[7][7] 永远是 h8

2. FEN 第一行表示 rank 8（a8 到 h8），不是 rank 1。

3. 从 FEN 解析棋盘时，必须进行如下映射：
   - FEN 第 0 行 → y = 7
   - FEN 第 7 行 → y = 0

4. 禁止在 UI 层、走棋判断层、Puzzle 层中再做任何“翻转”“视角适配”。

5. 玩家走棋判断必须基于内部坐标 (x,y)，
   而不是屏幕坐标。

你的任务：
- 找到当前代码中错误的 FEN → board 映射
- 只在解析阶段修复
- 不允许通过额外翻转 UI 或 Move 坐标来“补救”


标准棋盘（白方在下）
8 | a8 b8 c8 d8 e8 f8 g8 h8
7 | a7 b7 c7 d7 e7 f7 g7 h7
6 | a6 b6 c6 d6 e6 f6 g6 h6
5 | a5 b5 c5 d5 e5 f5 g5 h5
4 | a4 b4 c4 d4 e4 f4 g4 h4
3 | a3 b3 c3 d3 e3 f3 g3 h3
2 | a2 b2 c2 d2 e2 f2 g2 h2
1 | a1 b1 c1 d1 e1 f1 g1 h1
    -----------------------
    a  b  c  d  e  f  g  h
