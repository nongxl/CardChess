你是一个嵌入式 C++ 工程师，熟悉 cardputer、PlatformIO 和资源受限设备。
帮我开发一个项目，以下是详细需求：
    1.仿照原项目结构，开发一款运行于catdputer上的国际象棋应用:
        common.h用于引擎调用和规定下棋的逻辑规则，只负责：
            - 棋盘状态
            - 回合信息
            - 实现国际象棋的走子规则或将军判断。
            - 不包含 UI、不包含绘制、不包含引擎搜索
        draw_helper.h用于绘制棋盘、棋子、被吃的棋子、回合信息等
        icon_bmp.h用于定义棋子棋盘等元素的样式
        main.cpp是cardputer主程序用于调用各种资源和初始化
    2.原本文件中的代码作为资源调用的参考，可以删除原有逻辑代码，但必须保留文件结构与初始化顺序，不要改变 main.cpp 的入口模式
现阶段实现：
    1.实现裁判规则判定，高亮合法落子、判断将军/将死、安全生成 FEN、将来直接接Stockfish
    2.目前先实现显示棋盘、棋子、黑白方轮流动子（执白先行）、落子提示的基本功能。
    3.使用按键“分号（;）、句号（.）、逗号（,）、斜杠（/）、空格“分别控制”上、下、左、右、选子落子“
    4.选子按空格后，根据国际象棋的落子规则计算并在棋盘上高亮显示可落子的格子。
    5.开局可选择执白或执黑，区别是棋盘的方向。执白是白方在下，执黑时黑方在下。绝对坐标不变，也就是说a1永远是白棋的车
    6.cardputer的分辨率是240*135，除了中间显示正方形的棋盘（棋盘高度占满屏幕宽度），左右还有空白区域。被吃的棋子放在棋盘的左上和右下角（执棋方的右侧）。提示信息显示在右上角
以后考虑实现（预留设计的余地，先不要实现）：
    1.使用Stockfish这个国际象棋引擎，裁切到合适的量级
    2.实现FEN（Forsyth–Edwards Notation）存档到SD卡，开机能从存档加载棋盘状态
        FEN = 一行字符串，完整描述当前棋局状态
        格式固定为 6 个字段：
        <棋盘> <轮到谁> <易位权> <吃过路兵> <半回合> <全回合>
        示例（开局）：
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
    3.（可选）实现PGN（Portable Game Notation）对局记录，使用 SAN（标准代数记法）把下棋步骤保存为棋谱
        | 情况   | 记法          |
        | ---- | ----------- |
        | 兵走   | e4          |
        | 吃子   | exd5        |
        | 马    | Nf3         |
        | 象    | Bc4         |
        | 车    | R           |
        | 后    | Q           |
        | 王    | K           |
        | 将军   | +           |
        | 将死   | #           |
        | 王车易位 | O-O / O-O-O |
        | 升变   | e8=Q        |

    4.通过各种形式加载残局
以上 v0.1 版本需求，目标是“能稳定运行”，而不是功能齐全。请严格按步骤推进，不要提前实现未来功能。

【棋盘与坐标约定（不可违反）】

1. 棋盘使用绝对坐标系统（与 FEN 完全一致）：
   - a1 永远是白方左下角
   - h8 永远是黑方右上角
   - 规则逻辑与执白/执黑无关

2. 内部棋盘表示：
   index = rank * 8 + file
   file: a=0 … h=7
   rank: 1=0 … 8=7

   示例：
   a1 = 0, h1 = 7
   a8 = 56, h8 = 63

3. 执白 / 执黑只影响 UI 显示方向，
   不允许影响棋子初始摆放、规则或坐标系统。

4. 初始棋子摆放（绝对坐标）：
   白棋：王 e1，后 d1，车 a1 h1，马 b1 g1，象 c1 f1，兵 a2–h2
   黑棋：王 e8，后 d8，车 a8 h8，马 b8 g8，象 c8 f8，兵 a7–h7

5. 规则层与 UI 层必须严格分离：
   - 规则层只处理绝对坐标
   - UI 层可根据执白/执黑翻转显示

实现特殊走法前确认当前棋盘系统具备以下能力：
    - 使用绝对坐标（a1-h8），与 FEN 一致
    - 能判断基本走法合法性（不含特殊走法）
    - 能判断“是否将军”
    - 能维护棋盘状态（棋子类型、颜色、位置）
    - 有当前行棋方（side_to_move）

Prompt 开头（立法）
请在当前国际象棋裁判代码的基础上，实现以下三种特殊走法：
- 王车易位（Castling）
- 吃过路兵（En Passant）
- 兵的升变（Promotion）

重要约束（不可违反）：
1. 使用绝对棋盘坐标（a1 在左下，h8 在右上），与执白/执黑无关
2. 规则逻辑与 UI 显示完全分离
3. 不允许为特殊走法破坏或绕过已有的基本合法性判断
4. 特殊走法必须依赖棋盘状态，而不是仅依赖当前走子

♜ 一、王车易位（Castling）
实现王车易位规则：

王车易位是一种“王的特殊移动”，而不是车的移动。

前置条件（全部必须满足）：
1. 王和对应的车都从未移动过
2. 王当前未处于将军状态
3. 王与车之间的所有格子为空
4. 王经过的格子（包括起点、经过格、终点）均未被对方攻击

执行方式：
- 白王短易位：王从 e1 移动到 g1，车从 h1 移动到 f1
- 白王长易位：王从 e1 移动到 c1，车从 a1 移动到 d1
- 黑王短易位：王从 e8 移动到 g8，车从 h8 移动到 f8
- 黑王长易位：王从 e8 移动到 c8，车从 a8 移动到 d8

同时：
- 对应的车必须同步移动：
  - h1 → f1，a1 → d1
  - h8 → f8，a8 → d8

工程要求：
- 易位合法性判断必须使用“格子是否被攻击”的函数
- 不允许通过“临时落子再回滚”来判断是否合法

♟ 二、吃过路兵（En Passant）
实现吃过路兵规则：

吃过路兵是一种“条件触发的兵吃子规则”。

前置条件：
1. 上一回合，对方兵从初始位置前进了两格
2. 当前兵位于该兵的相邻列
3. 当前回合必须立即执行，不能延后

执行方式：
- 白兵位于第 5 排（rank 5），吃黑兵：
  - 白兵从 e5 移动到 d6 或 f6
  - 被吃掉的黑兵位于 d5 或 f5（不是目标格）
- 黑兵位于第 4 排（rank 4），吃白兵：
  - 黑兵从 e4 移动到 d3 或 f3
  - 被吃掉的白兵位于 d4 或 f4

工程要求：
- 吃过路兵目标格必须来自“上一手棋”的记录
- 吃子时，目标格为空，但必须移除被吃兵
- 吃过路兵不能造成己方王暴露在将军中
当对方兵刚刚从初始位走两格时，必须记录该兵跳过的格子作为 enPassantSquare。
在下一手生成兵走法时，如果我方兵可以斜向一步移动到 enPassantSquare，即使该格子为空，也必须生成一个吃过路兵走法，并在执行时移除对方刚走两格的兵。

♕ 三、兵的升变（Promotion）
实现兵的升变规则：

兵的升变在兵移动到最后一排后立即发生。

前置条件：
- 白兵到达 rank 8
- 黑兵到达 rank 1

执行方式：
1. 升变发生在兵完成合法移动之后
2. 升变兵种必须为：后、车、象、马（不允许升变为王或兵）
3. 默认升变为后（Queen），除非指定其他类型

工程要求：
- 升变必须修改棋盘中的棋子类型
- 升变不能跳过“是否合法移动”的检查
- 升变后必须重新评估将军状态

🛠 四、实现层面的统一要求（非常重要）
实现要求：
1. 不允许在一个函数中同时处理规则判断和棋盘修改
2. 特殊走法必须通过明确的条件分支处理
3. 所有特殊走法都必须能被 FEN 正确表示
4. 若特殊走法不满足条件，应明确返回非法

五、实现过程要求
如果需要新增状态字段（如是否移动过、en passant 目标格），
请先列出需要的字段及含义，再实现代码。
不要在未说明状态的情况下直接写逻辑。

接下来实现“兵升变选择棋子”的功能，但请严格按以下拆分实现，避免一次性改动过大。

1. 规则层（不涉及 UI）

当兵移动到最后一排（白：rank 8，黑：rank 1）时，触发“升变状态”。

在升变完成前，该兵仍保留为“待升变兵”，棋盘逻辑暂停，不允许任何其它走子。

升变的可选棋子固定为：皇后、车、马、象（不允许兵、王）。

2. 升变选择状态（新增状态机）

进入 PromotionSelecting 状态后：

记录当前升变兵的位置和所属颜色

默认选择棋子为“皇后”

仅响应左右键和确认键，其它输入全部忽略

3. UI 展示规则（最小可实现方案）

以升变兵所在的格子为中心，在棋盘上方渲染一行 4 个“浮动选择格子”

这 4 个格子不占用棋盘坐标，仅作为 UI 覆盖层显示

从左到右依次为：车、马、皇后、象

当前选中的棋子高亮显示

棋盘其余区域加半透明遮罩，仅用于视觉提示，不影响逻辑

升变选择 UI 的水平位置遵循以下规则：
默认情况下，将 4 个选择格子水平居中对齐到升变兵所在列
如果左侧空间不足以容纳全部格子，则整体向右移动，直到最左格子与棋盘左边界对齐
如果右侧空间不足以容纳全部格子，则整体向左移动，直到最右格子与棋盘右边界对齐
无论如何，4 个选择格子必须全部显示在棋盘范围内

4. 输入规则

左右键：在 4 个选项之间循环移动选择

确认键（空格）：确定当前选择

5. 确认后的逻辑

将升变兵从棋盘中移除

在原格子放置玩家所选的新棋子

退出 PromotionSelecting 状态

恢复正常对局流程，切换回合

6. 特别约束（避免常见 bug）

升变选择必须是一个独立状态，不允许通过临时变量硬塞

UI 选择不应直接修改棋盘数据，只有确认后才更新棋盘

不允许在升变过程中触发将军、将死、和棋判断

请先实现规则和状态切换，再实现 UI，最后接入输入逻辑。


引入下棋ai引擎
AI 类型：Greedy AI + 极浅搜索（Depth 1）
目标：在 ESP32 / Cardputer 上稳定运行
不追求棋力，只追求“看起来在下棋”
请基于当前已有的国际象棋裁判系统，实现一个轻量级下棋 AI，
用于在 ESP32 / Cardputer 上离线运行。

【前提条件】
- 已存在合法走法生成逻辑：
  - generateValidMoves(from)
  - getValidMoves() -> vector<Position>
  - hasValidMoves()
- 所有返回的走法均保证合法且不会使己方王被将军
- 使用绝对坐标系统（x: 0–7, y: 0–7）
- 不修改 UI 逻辑

【AI 目标】
- AI 只负责“选择一步走法”
- 不实现复杂搜索或引擎
- 响应时间应尽可能短

【AI 结构要求】
1. 定义 Move 结构：
   struct Move { Position from; Position to; };

2. 实现函数：
   Move chooseAIMove(Color side);

3. chooseAIMove 的流程：
   a) 遍历棋盘上所有属于 side 的棋子
   b) 对每个棋子调用 generateValidMoves(from)
   c) 汇总所有合法走法为 vector<Move>
   d) 对每个 Move 进行评分（见下）
   e) 返回评分最高的 Move
   f) 若多个 Move 得分相同，可随机选择一个

【评估函数（Depth 1）】
对每个走法只评估当前这一步，不做递归搜索。

评分规则（可直接使用）：
- 吃子：+ 被吃棋子的子力分
- 将军：+2
- 控制中心格（d4/e4/d5/e5）：+1

子力分定义：
- 后 9
- 车 5
- 象 3
- 马 3
- 兵 1

【工程约束（非常重要）】
- 不允许在评估过程中修改真实棋盘状态
- 使用“临时拷贝棋盘”的方式模拟走子
- 不允许在 AI 中处理 UI、音效或历史记录
- AI 不需要处理悔棋、存档或网络
- 不允许修改现有裁判逻辑

【实现建议】
- 使用 Board backup = board; 的方式临时模拟走子
- 评估完成后恢复 board = backup
- 保证代码可在 PlatformIO + C++17 下编译
- AI 只“选棋”，
- 游戏系统负责“走棋”。

待实现：
50回合规则